# -*- coding: utf-8 -*-
"""projetdev.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bE0vSp1Y6JDuurY1E-7yllA0zrja2Pfv
"""

import pandas as pd

# Load dataset
df = pd.read_csv("diabetes_prediction_dataset.csv")
df.head()

#check general info about the dataset + check null values

df.info()
df.describe()
df['diabetes'].value_counts(normalize=True)

df.isnull().sum()

import pandas as pd

# Encode gender
df['gender'] = df['gender'].replace({'Male': 1, 'Female': 0, 'Other': 2})

# Encode smoking_history
df = pd.get_dummies(df, columns=['smoking_history'], drop_first=True)

#Split feature and target

X = df.drop('diabetes', axis=1)
y = df['diabetes']

#Split Data

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

#handle class imbalance using SMOTE (Synthetic Minority Over-sampling)

from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)
X_train_res, y_train_res = smote.fit_resample(X_train, y_train)

#Feature Scaling

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train_res)
X_test_scaled = scaler.transform(X_test)

#scaling numeric data

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_scaled_df = pd.DataFrame(X_scaled, columns=X.columns)
X_scaled_df['diabetes'] = y.values

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

#Histogram / KDE plots by class

features_to_plot = ['age', 'bmi', 'HbA1c_level', 'blood_glucose_level']

for col in features_to_plot:
    plt.figure(figsize=(6,4))
    sns.kdeplot(data=X_scaled_df, x=col, hue='diabetes', fill=True, common_norm=False, palette='Set2')
    plt.title(f'{col} Distribution by Diabetes')
    plt.show()

#Correlation Heatmap

plt.figure(figsize=(10,8))
sns.heatmap(X_scaled_df.corr(), cmap='coolwarm', annot=True, fmt=".2f")
plt.title("Feature Correlation Heatmap")
plt.show()

#Dimensionality Reduction with PCA (for 2D visualization)
#Movement along PC1 = differences in blood sugar metrics
#Movement along PC2 = differences in age/heart conditions

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

pca_df = pd.DataFrame(data=X_pca, columns=['PC1', 'PC2'])
pca_df['diabetes'] = y.values

plt.figure(figsize=(7,5))
sns.scatterplot(data=pca_df, x='PC1', y='PC2', hue='diabetes', palette='coolwarm', alpha=0.6)
plt.title('PCA Projection of Patients')
plt.show()

#Pairwise Feature Relationships

sns.pairplot(X_scaled_df[['age','bmi','HbA1c_level','blood_glucose_level','diabetes']], hue='diabetes', diag_kind='kde', corner=True)
plt.show()

# Core
import pandas as pd
import numpy as np

# Modeling
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

# Metrics
from sklearn.metrics import classification_report, roc_auc_score, confusion_matrix

# SMOTE for imbalance
from imblearn.over_sampling import SMOTE

#logistic Regression

lr = LogisticRegression(max_iter=1000, random_state=42)
lr.fit(X_train_res, y_train_res)
y_pred_lr = lr.predict(X_test)
print("Logistic Regression Results:")
print(classification_report(y_test, y_pred_lr))
print("ROC-AUC:", roc_auc_score(y_test, lr.predict_proba(X_test)[:, 1]))

#Results
from sklearn.metrics import recall_score, roc_auc_score

results = pd.DataFrame({
    'Model': ['Logistic Regression'],
    'Recall': [
        recall_score(y_test, y_pred_lr),
    ],
    'ROC-AUC': [
        roc_auc_score(y_test, lr.predict_proba(X_test)[:,1]),
    ]
})

print(results.sort_values(by='ROC-AUC', ascending=False))

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred_lr))

#Random forest

rf = RandomForestClassifier(random_state=42)
rf.fit(X_train_scaled, y_train_res)
y_pred_rf = rf.predict(X_test_scaled)
print(classification_report(y_test, y_pred_rf))
print("ROC-AUC:", roc_auc_score(y_test, rf.predict_proba(X_test_scaled)[:,1]))

#Confusion Matrix for the Random Forest model

from sklearn.metrics import ConfusionMatrixDisplay
ConfusionMatrixDisplay.from_estimator(rf, X_test_scaled, y_test, cmap='Blues')

!pip install streamlit pyngrok

from pyngrok import ngrok

# Replace with your token
!ngrok authtoken "33pmBtwYgOI4POULv5qglvZLQVx_49fL42ryyt23rHrvHW8Yq"

#Save the trained model
import joblib

# Replace `lr` by your actual trained model variable if different (e.g., rf, xgb, etc.)
joblib.dump(lr, "diabetes_model.pkl")
print("Model saved as diabetes_model.pkl ‚úÖ")

# Auto-generated Streamlit app for diabetes prediction
import streamlit as st
import numpy as np
import joblib
import os
st.set_page_config(page_title='Diabetes Prediction', layout='centered')
st.title('ü©∫ Diabetes Prediction')
MODEL_PATH = 'diabetes_model.pkl'
model = None
if os.path.exists(MODEL_PATH):
    try:
        model = joblib.load(MODEL_PATH)
    except Exception as e:
        st.error('Failed to load model: ' + str(e))
st.sidebar.header('Patient data')
diabetes = st.sidebar.text_input('diabetes', value='')
gender = st.sidebar.text_input('gender', value='')
PC1 = st.sidebar.text_input('PC1', value='')
PC2 = st.sidebar.text_input('PC2', value='')
smoking_history = st.sidebar.text_input('smoking_history', value='')
input_vals = []
input_vals.append(diabetes)
input_vals.append(gender)
input_vals.append(PC1)
input_vals.append(PC2)
input_vals.append(smoking_history)
if st.button('Predict'):
    if model is None:
        st.warning("No trained model found. Save a model as 'diabetes_model.pkl' in the working directory.")
    else:
        try:
            X = np.array(input_vals, dtype=float).reshape(1, -1)
            pred = model.predict(X)
            try:
                proba = model.predict_proba(X)[0]
            except Exception:
                proba = None
            label = 'Diabetic' if int(pred[0])==1 else 'Non-diabetic'
            st.success('Prediction: ' + label)
            if proba is not None:
                st.info('Probabilities: ' + str(proba))
        except Exception as e:
            st.error('Prediction failed: ' + str(e))

st.markdown('---')
st.write('If you need to train and save a model in the notebook, run:')
st.code("""from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model.fit(X_train, y_train)
import joblib
joblib.dump(model, 'diabetes_model.pkl')""")

# ‚úÖ Step 3 - Run Streamlit app in Colab
!pip install -q streamlit pyngrok

from pyngrok import ngrok
public_url = ngrok.connect(8501)
print("üåç Streamlit app URL:", public_url)

# Run Streamlit app
!streamlit run app.py &>/dev/null&

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import joblib
# import pandas as pd
# 
# # --------------------------------------------------
# # Setup
# # --------------------------------------------------
# st.set_page_config(page_title='ü©∫ Diabetes Prediction App', layout='centered')
# st.title('ü©∫ Diabetes Prediction App')
# 
# # Load trained model
# model = joblib.load('diabetes_model.pkl')
# 
# # --------------------------------------------------
# # Sidebar Inputs
# # --------------------------------------------------
# st.sidebar.header('Patient Information')
# gender = st.sidebar.selectbox('Gender', ['Male', 'Female'])
# age = st.sidebar.number_input('Age', 0, 120, 30)
# bmi = st.sidebar.number_input('BMI', 10.0, 60.0, 25.0)
# hypertension = st.sidebar.selectbox('Hypertension (1=yes, 0=no)', [0, 1])
# heart_disease = st.sidebar.selectbox('Heart Disease (1=yes, 0=no)', [0, 1])
# smoking_history = st.sidebar.selectbox(
#     'Smoking History',
#     ['never', 'former', 'current', 'ever', 'not current']
# )
# HbA1c_level = st.sidebar.number_input('HbA1c Level', 3.0, 15.0, 5.5)
# blood_glucose_level = st.sidebar.number_input('Blood Glucose Level', 50, 300, 120)
# 
# # --------------------------------------------------
# # Prepare Input Data
# # --------------------------------------------------
# input_data = pd.DataFrame({
#     'gender': [gender],
#     'age': [age],
#     'hypertension': [hypertension],
#     'heart_disease': [heart_disease],
#     'bmi': [bmi],
#     'HbA1c_level': [HbA1c_level],
#     'blood_glucose_level': [blood_glucose_level],
#     'smoking_history': [smoking_history]
# })
# 
# # --------------------------------------------------
# # Encoding Logic
# # --------------------------------------------------
# 
# # --- Handle gender ---
# if 'gender_Male' in model.feature_names_in_ or 'gender_Female' in model.feature_names_in_:
#     # One-hot encoding case
#     input_data['gender_Male'] = 1 if gender == 'Male' else 0
#     input_data['gender_Female'] = 1 if gender == 'Female' else 0
#     input_data.drop(columns=['gender'], inplace=True)
# else:
#     # Label encoded case (Male=1, Female=0)
#     input_data['gender'] = 1 if gender == 'Male' else 0
# 
# # --- Handle smoking_history ---
# smoking_options = ['smoking_history_current', 'smoking_history_ever',
#                    'smoking_history_former', 'smoking_history_never',
#                    'smoking_history_not current']
# 
# if any(col in model.feature_names_in_ for col in smoking_options):
#     # One-hot encode smoking_history
#     for col in smoking_options:
#         input_data[col] = 1 if col == f'smoking_history_{smoking_history}' else 0
#     input_data.drop(columns=['smoking_history'], inplace=True)
# else:
#     # Label encoding fallback
#     mapping = {'never': 0, 'former': 1, 'current': 2, 'ever': 3, 'not current': 4}
#     input_data['smoking_history'] = mapping[smoking_history]
# 
# # --------------------------------------------------
# # Align columns with model‚Äôs expected input
# # --------------------------------------------------
# model_features = model.feature_names_in_
# for col in model_features:
#     if col not in input_data.columns:
#         input_data[col] = 0
# input_data = input_data[model_features]
# 
# # --------------------------------------------------
# # Prediction
# # --------------------------------------------------
# if st.button('Predict'):
#     try:
#         prediction = model.predict(input_data)
#         result = 'ü©∏ Diabetic' if prediction[0] == 1 else '‚úÖ Non-Diabetic'
#         st.success(f'Prediction: {result}')
#     except Exception as e:
#         st.error(f"Error during prediction: {e}")
# 
#

from pyngrok import ngrok
ngrok.kill()
public_url = ngrok.connect(8501)
print("üåç", public_url)
!streamlit run app.py --server.port 8501 --server.address 0.0.0.0 &

!ls -lh